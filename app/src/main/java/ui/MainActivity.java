package ui;

import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.ViewModelProvider;

import android.os.Bundle;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import algonquin.cst2335.sunrisesunsetlookup.databinding.ActivityMainBinding;
import algonquin.cst2335.sunrisesunsetlookup.data.MainViewModel;

public class MainActivity extends AppCompatActivity {
    //? Attributes
    private ActivityMainBinding variableBinding;
    private MainViewModel model;


    /**
     * Starting point of an Android application
     *
     * @param savedInstanceState
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);// Calls parent onCreate()

        //?AppCompatActivity: Represent the View (page on the screen). Uses ViewBinding to hold all of the widgets on the screen.
        //? With this line of code, we are connecting AppCompactActivity to the ViewModel
        model = new ViewModelProvider(this).get(MainViewModel.class);

        //R stands for the /res folder. R.layout means there is a folder called layout inside /res folder
        // This function is loading the file activity_main.xml
        //setContentView(R.layout.activity_main);

        //? Loading the views (widgets) into memory:
        /*
         * Note: Inflating refers to the process of converting an XML layout file into the
         * corresponding objects in memmory
         *
         * View binding automatically loads all of the widgets in our layout (activity_main.xml) and
         * assigns them to Java variables automatically. There is no need to use findViewById() to
         * load the widgets from the XML, the compiler will automatically declare the variables.
         *
         * ActivityMainBinding is automatically generated by the View Binding system based on the layout
         * of our activity_main.xml and creates an object that provides direct references to the
         * views (widgets) in our layout (activity_main.xml)
         *
         * inflate(getLayoutInflater()) is used to create an instance of the binding class. This process
         * inflates the layout defined in activity_main.xml and creates an object that provides direct
         * references to the views (widgets) in our layout.
         */
        variableBinding = ActivityMainBinding.inflate(getLayoutInflater());

        /*
         * With binding we no longer need to call finViewById() because the compiler has pre-declared
         * all the views in the Binding class. ViewBinding guarantees that the variables we are using
         * are part of the layout we have inflated.
         */

        TextView myText = variableBinding.textview;
        Button myButton = variableBinding.mybutton;
        EditText myEdit = variableBinding.myedittext;

        //? Actions on the widgets
        /*
         * Buttons:
         *   to specify an action when the button is pressed, we must set a click listener on
         *   the button object.
         *
         *   View.OnClickListener wires the listener to the button using setOnClickListener. As a
         *   result, the app will execute the code in onClickView after the user presses the button
         *
         */

        //* By sending the attribute editString of the MainViewModel to myedittext widget we ensure
        // * that the text survives the orientation changes

        variableBinding.myedittext.setText(model.editString.getValue());

        variableBinding.mybutton.setOnClickListener(click -> {
            /*
             * Set the editString variable on MainViewModel to the current value of the Edit text so
             * it does not get lost when rotating the device.
             *
             * Whenever we want to change the value of a MutableLiveData variable of MainViewModel,
             * we can use the postValue() function.
             *
             */
            model.editString.postValue(variableBinding.myedittext.getText().toString());
        });

        /*
         * postValue() not only change the value, but it also notifies any objects that are
         * observing this variable for changes. This is achieve by implementing the Observer
         * Pattern. To achieve this we must register to be an observer of the MutableLiveData
         * variable by calling the Observer interface implemented by the MutableLiveData class.
         * This class has a single function called onChanged(), which gets called whenever the
         * MutableLiveData object changes its values.
         */

        model.editString.observe(this, (s) -> {
            myText.setText("Your edit has changed to: " + s);
        });

        /*
         * Sets the content view of the activity to the root view of the layout. By calling
         * binding.getRoot() in setContentView() we are specifying that the content of the activity
         * should be the layout defined in activity_main.xml
         */
        setContentView(variableBinding.getRoot());

        variableBinding.radioButton.setOnCheckedChangeListener((button, onOrOff) -> {
            model.onOrOff.postValue(onOrOff);
        });


        model.onOrOff.observe(this, newValue -> {
            variableBinding.radioButton.setChecked(newValue);
            //? Toast object
            String toastValue = "The value is " + newValue;
            //* Instantiate the Toast Object
            Toast.makeText(this, toastValue, Toast.LENGTH_SHORT).show();
        });





    }
}