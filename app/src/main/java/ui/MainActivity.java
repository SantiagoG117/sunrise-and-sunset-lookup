package ui;

import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.Observer;
import androidx.lifecycle.ViewModelProvider;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import algonquin.cst2335.sunrisesunsetlookup.databinding.ActivityMainBinding;
import algonquin.cst2335.sunrisesunsetlookup.data.MainViewModel;

public class MainActivity extends AppCompatActivity {
    //? Attributes
    private ActivityMainBinding binding;
    private MainViewModel model;


    /**
     * Starting point of an Android application
     *
     * @param savedInstanceState
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);// Calls parent onCreate()

        //?AppCompatActivity: Represent the View (page on the screen). Uses ViewBinding to hold all of the widgets on the screen.
        //? With this line of code, we are connecting AppCompactActivity to the ViewModel
        model = new ViewModelProvider(this).get(MainViewModel.class);

        //R stands for the /res folder. R.layout means there is a folder called layout inside /res folder
        // This function is loading the file activity_main.xml
        //setContentView(R.layout.activity_main);

        //? Loading the views (widgets) into memory:
        /*
         * Note: Inflating refers to the process of converting an XML layout file into the
         * corresponding objects in memmory
         *
         * View binding automatically loads all of the widgets in our layout (activity_main.xml) and
         * assigns them to Java variables automatically. There is no need to use findViewById() to
         * load the widgets from the XML, the compiler will automatically declare the variables.
         *
         * ActivityMainBinding is automatically generated by the View Binding system based on the layout
         * of our activity_main.xml and creates an object that provides direct references to the
         * views (widgets) in our layout (activity_main.xml)
         *
         * inflate(getLayoutInflater()) is used to create an instance of the binding class. This process
         * inflates the layout defined in activity_main.xml and creates an object that provides direct
         * references to the views (widgets) in our layout.
         */
        binding = ActivityMainBinding.inflate(getLayoutInflater());

        /*
         * Sets the content view of the activity to the root view of the layout. By calling
         * binding.getRoot() in setContentView() we are specifying that the content of the activity
         * should be the layout defined in activity_main.xml
         */
        setContentView(binding.getRoot());




        /*
         When we call a given view we need to store the result in a variable to call functions later
         The Java class name always matches the <XML> tag of the object with the ID we are calling.
         */
        //TextView myText = findViewById(R.id.textview);
        //Button myButton = findViewById(R.id.mybutton);
        //EditText myEdit = findViewById(R.id.myedittext);

        /*
         * With binding we no longer need to call finViewById() because the compiler has pre-declared
         * all the views in the Binding class. ViewBinding guarantees that the variables we are using
         * are part of the layout we have inflated.
         */

        TextView myText = binding.textview;
        Button myButton = binding.mybutton;
        EditText myEdit = binding.myedittext;


        //? Actions on the widgets

        /*
         * Buttons:
         *   to specify an action when the button is pressed, we must set a click listener on
         *   the button object.
         *
         *   View.OnClickListener wires the listener to the button using setOnClickListener. As a
         *   result, the app will execute the code in onClickView after the user presses the button
         *
         */

        //* By sending the attribute editString of the MainViewModel to myedittext widget we ensure
        // * that the text survives the orientation changes
        // Prevents that when we click on the button, we set the text of the Ma
        binding.myedittext.setText((CharSequence) model.editString);

        binding.mybutton.setOnClickListener(click -> {
            /*
            * Set the editString variable on MainViewModel to the current value of the Edit text so
            * it does not get lost when rotating the device.
            *
            * Whenever we want to change the value of a MutableLiveData variable of MainViewModel,
            * we can use the postValue() function.
             */
            model.editString.postValue(binding.myedittext.getText().toString());

            /*
            * postValue() not only change the value, but it* also notifies any objects that are
            * observing this variable for changes. This is achieve by implementing the Observer
            * Pattern. To achieve this we must register to be an observer of the MutableLiveData
            * variable by calling the Observer interface implemented by the MutableLiveData class.
            * This class has a single function called onChanged(), which gets called whenever the
            * MutableLiveData object changes its values.
             */

            model.editString.observe(this, s -> {
                binding.myedittext.setText("Your edit text has: " + s);
            });
        });
        /*myButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //Code here executes on main thread after user presses button
                //* Returns a String representing the text currently shown by the object
                String editString = myEdit.getText().toString();
                //* Set a new value to the EditText
                myEdit.setText("Your edit text has: " + editString);
            }
        });*/



    }
}